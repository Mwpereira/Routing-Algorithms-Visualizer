// This file contains the implementation of the Distance Vector Routing algorithm
import { convertCanvasGraphOutput } from '../utilities/canvas-converter'

// Update the distance vector for each node in the network
export const distanceVectorAlgorithm = (graph, numberOfIterations) => {
    const convertedGraph = convertCanvasGraphOutput(graph)
    return distanceVector(convertedGraph, numberOfIterations)
}

// Distance Vector Routing Algorithm
// Graph is taken in the form of an adjacency list along with the number of iterations we want the
// routers to communicate
function distanceVector(graph, numberOfIterations) {
    let steps = []

    // Get the number of nodes in the network
    const numNodes = Object.keys(graph).length

    // Initialize the distance vectors to infinity for all nodes except the ones that are directly connected to the node

    // arr[node][distance]
    let distanceVectors = Array.from({ length: numNodes }, () => Array.from({ length: numNodes }, () => Infinity))

    // init distanceVectors with the values to themselves
    for (let i = 0; i < numNodes; i++) {
        distanceVectors[i][i] = 0
    }

    // Add the distances from each router to the tables of each (distanceVectors)
    for (const [startNode, [startNodeKey, startNodeValue]] of Object.entries(Object.entries(graph))) {
        for (const [endNode, [endNodeKey, endNodeValue]] of Object.entries(Object.entries(graph[startNodeKey]))) {
            distanceVectors[startNode][Object.keys(graph).indexOf(endNodeKey)] = graph[startNodeKey][endNodeKey]
        }
    }

    // autogenerated text description of what the algorithm is doing
    let text =
        `We have initialized the tables for all the ${numNodes} routers. This initial step is where the ` +
        `routers have not communicated with each other yet (t=0).`

    // This is used to decouple the pass by reference in the variable
    let updatedVectors = JSON.parse(JSON.stringify(distanceVectors))
    steps.push({ distanceVectors: updatedVectors, text })

    // Run the distance-vector algorithm for numIterations iterations
    for (let iteration = 1; iteration <= numberOfIterations; iteration++) {
        // Update the distance vector for each node in the network
        const updatedDistanceVector = updateDistanceVector(numNodes, distanceVectors, graph, iteration)
        distanceVectors = updatedDistanceVector.distanceVectors
        let updatedVectorsDupe = JSON.parse(JSON.stringify(distanceVectors))
        text = updatedDistanceVector.text
        steps.push({ distanceVectors: updatedVectorsDupe, text })
    }

    return { distanceVectors, steps }
}

// Update the distance vector for each node in the network
function updateDistanceVector(numNodes, distanceVectors, graph, iter) {
    let text = ``
    let index_to_key_mapping = Object.keys(graph)

    // This is used to decouple the pass by reference in the variable
    let main_distanceVector = JSON.parse(JSON.stringify(distanceVectors))

    // handling the values changed from JSON parse and stringify
    for (let i = 0; i < main_distanceVector.length; i++) {
        for (let j = 0; j < main_distanceVector[i].length; j++) {
            if (main_distanceVector[i][j] === null) {
                main_distanceVector[i][j] = Infinity
            }
        }
    }

    // Here the router's receive the tables from other routers, and we update the shortest paths for each router
    for (let node = 0; node < numNodes; node++) {
        for (let neighborNode = 0; neighborNode < numNodes; neighborNode++) {
            if (neighborNode === node) {
                continue
            }
            for (let i = 0; i < numNodes; i++) {
                // ignore if node is referencing itself
                if (i === node) {
                    continue
                }

                // check whether the distance from the neighbour's table is faster/shorter than the one already in
                // the table of the router
                if (
                    main_distanceVector[node][neighborNode] + main_distanceVector[neighborNode][i] <
                    main_distanceVector[node][i]
                ) {
                    text +=
                        `We found that through router ${index_to_key_mapping[node]} to ` +
                        `${index_to_key_mapping[neighborNode]} we can go to ${index_to_key_mapping[i]} faster. ` +
                        `The distance compared is (` +
                        `${main_distanceVector[node][neighborNode] + main_distanceVector[neighborNode][i]} < ${
                            main_distanceVector[node][i]
                        }).\n\n`

                    distanceVectors[node][i] =
                        main_distanceVector[node][neighborNode] + main_distanceVector[neighborNode][i]
                }
            }
        }
    }

    // check whether algorithm has performed any changes during this step
    if (text.length < 1) {
        text = `There were no shorter paths when comparing with other routers in this step: t = ${iter}`
    }

    return { distanceVectors, text }
}
